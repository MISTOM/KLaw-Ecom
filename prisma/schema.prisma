generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int                @id @default(autoincrement())
  name             String
  email            String             @unique
  password         String
  idNumber         Int?
  phoneNumber      String?
  address          String?
  refreshToken     String?
  isVerified       Boolean            @default(false)
  imageId          Int?
  roleId           Int
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  postalCode       String?
  Cart             Cart?
  DocAccessLog     DocAccessLog[]
  Entitlement      Entitlement[]
  Order            Order[]
  Payment          Payment[]
  profileImage     Image?             @relation(fields: [imageId], references: [id])
  role             Role               @relation(fields: [roleId], references: [id])
  UserSubscription UserSubscription[]
}

model Product {
  id               Int                @id @default(autoincrement())
  name             String
  description      String
  price            Float
  quantity         Int
  author           String
  pageCount        Int
  publicationDate  DateTime
  serviceCode      String             @unique
  isPublished      Boolean            @default(false)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  sortOrder        Int                @default(999)
  citation         String?
  ISBN             String?
  CartItem         CartItem[]
  Image            Image[]
  ProductOnOrder   ProductOnOrder[]
  ProductPromotion ProductPromotion[]
  categories       Category[]         @relation("ProductCategory")
  ProductDocument  ProductDocument[] // Related PDF documents for this product
}

model Image {
  id        Int      @id @default(autoincrement())
  productId Int
  url       String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  User      User[]
}

model Category {
  id                Int                 @id @default(autoincrement())
  name              String
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  sortOrder         Int                 @default(999)
  CategoryPromotion CategoryPromotion[]
  Products          Product[]           @relation("ProductCategory")
}

model Cart {
  id               Int        @id @default(autoincrement())
  userId           Int        @unique
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt
  paymentReference String?    @unique
  status           CartStatus @default(ACTIVE)
  user             User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  CartItem         CartItem[]
}

model CartItem {
  id        Int      @id @default(autoincrement())
  cartId    Int
  productId Int
  quantity  Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  cart      Cart     @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product   Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
}

model Order {
  id             Int              @id @default(autoincrement())
  totalPrice     Float
  status         OrderStatus      @default(PENDING)
  billRefNumber  String           @unique
  invoiceNumber  String?          @unique
  description    String?
  userId         Int
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  Payment        Payment[]
  ProductOnOrder ProductOnOrder[]
}

model ProductOnOrder {
  orderId        Int
  productId      Int
  quantity       Int
  isIssued       Boolean    @default(false)
  order          Order      @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product        Product    @relation(fields: [productId], references: [id])
  /// Base unit price at time of order BEFORE discount (snapshot to preserve historical pricing)
  unitPrice      Float      @default(0)
  /// Absolute discount amount applied per unit (0 if none)
  discountAmount Float      @default(0)
  /// Optional promotion reference used to derive discount
  promotionId    Int?
  promotion      Promotion? @relation(fields: [promotionId], references: [id])

  @@id([orderId, productId])
}

model ConvenienceFee {
  id        Int      @id @default(autoincrement())
  name      String?
  amount    Float    @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Role {
  id        Int      @id @default(autoincrement())
  name      Roles    @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  User      User[]
}

model Payment {
  id             Int               @id @default(autoincrement())
  userId         Int
  orderId        Int?
  subscriptionId Int?
  provider       String
  status         PaymentStatus     @default(PENDING)
  amount         Int
  currency       String            @default("KES")
  providerRef    String?           @unique
  idempotencyKey String?           @unique
  rawPayload     Json?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  order          Order?            @relation(fields: [orderId], references: [id], onDelete: Cascade)
  subscription   UserSubscription? @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([orderId])
  @@index([subscriptionId])
  @@index([status])
}

model Promotion {
  id            Int                 @id @default(autoincrement())
  name          String
  description   String?
  discountType  DiscountType
  discountValue Int
  code          String?             @unique
  startsAt      DateTime
  endsAt        DateTime
  isActive      Boolean             @default(true)
  priority      Int                 @default(100)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  categories    CategoryPromotion[]
  products      ProductPromotion[]
  orders        ProductOnOrder[]
}

model ProductPromotion {
  promotionId Int
  productId   Int
  product     Product   @relation(fields: [productId], references: [id], onDelete: Cascade)
  promotion   Promotion @relation(fields: [promotionId], references: [id], onDelete: Cascade)

  @@id([promotionId, productId])
  @@index([productId])
}

model CategoryPromotion {
  promotionId Int
  categoryId  Int
  category    Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  promotion   Promotion @relation(fields: [promotionId], references: [id], onDelete: Cascade)

  @@id([promotionId, categoryId])
  @@index([categoryId])
}

model LegislationItem {
  id                    Int             @id @default(autoincrement())
  year                  Int
  type                  LegislationType
  number                String?
  title                 String?
  dateGazetted          DateTime?
  gazetteDetails        String?
  availabilityAt        DateTime?
  uploadedAt            DateTime?
  kgsPublicationAt      DateTime?
  commencementAt        DateTime?
  pagination            String?
  statusOnDatabase      String?
  legislativeUpdates    String?
  comments              String?
  kenyaGazetteSuppNo    String?
  revocationsAmendments String?
  assentAt              DateTime?
  dateAvailedAt         DateTime?
  availability          String?
}

model UserSubscription {
  id        Int                @id @default(autoincrement())
  userId    Int
  planId    Int
  status    SubscriptionStatus @default(ACTIVE)
  startsAt  DateTime           @default(now())
  endsAt    DateTime?
  isActive  Boolean            @default(true)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  Payment   Payment[]
  plan      SubscriptionPlan   @relation(fields: [planId], references: [id])
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isActive])
}

model SubscriptionPlan {
  id               Int                @id @default(autoincrement())
  name             String             @unique
  description      String?
  price            Int
  duration         Int
  isActive         Boolean            @default(true)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  UserSubscription UserSubscription[]
}

/// Secure document metadata (Iteration 1)
/// Reason: Stores per-document wrapped AES content key so raw key never resides in DB.
model Document {
  id           Int            @id @default(autoincrement())
  title        String
  pageCount    Int
  wrappedKey   String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  DocAccessLog DocAccessLog[]
  Entitlement  Entitlement[]
}

/// User entitlement to view a document
/// Reason: Ties a user to a document with an optional expiry window.
model Entitlement {
  id         Int       @id @default(autoincrement())
  userId     Int
  documentId Int
  grantedAt  DateTime  @default(now())
  expiresAt  DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  document   Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, documentId])
  @@index([documentId])
}

/// Per-page access log (minimal PII) for auditing/rate limiting
/// Reason: Track access patterns and detect scraping attempts while minimizing PII stored.
model DocAccessLog {
  id         Int      @id @default(autoincrement())
  userId     Int
  documentId Int
  page       Int
  ip         String?
  userAgent  String?
  timestamp  DateTime @default(now())
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([documentId, page])
}

enum CartStatus {
  ACTIVE
  PENDING_PAYMENT
  COMPLETED
}

enum OrderStatus {
  PENDING
  COMPLETED
  CANCELLED
}

enum Roles {
  ADMIN
  USER
}

/// Payment status lifecycle
enum PaymentStatus {
  PENDING
  AUTHORIZED
  SUCCEEDED
  FAILED
  CANCELLED
  REFUNDED
}

enum DiscountType {
  PERCENT
  AMOUNT
}

enum LegislationType {
  ACT
  SUBLEG
  CORRIGENDA
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
}

/// PDF document associated with a product (non-DRM)
/// Reason: Enables attaching one or more plain PDF files to a product which subscribed users can read.
model ProductDocument {
  id             Int      @id @default(autoincrement())
  productId      Int
  originalName   String // Original filename from the upload
  storedName     String // Internal unique filename stored on disk (uuid.pdf)
  mimeType       String   @default("application/pdf")
  sizeBytes      Int // File size in bytes for display & validation
  checksumSha256 String? // For replacement detection (nullable to allow backfill)
  pageCount      Int? // Optional extracted page count (future enhancement)
  sortOrder      Int      @default(999)
  isPublished    Boolean  @default(true) // Can hide a document without deleting
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  product        Product  @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([productId, storedName])
  @@index([productId])
  @@index([isPublished])
}
